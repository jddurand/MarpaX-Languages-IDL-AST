[%~#
   # Notes
   #
   # We will use the following translation of IDL.
   # In the third column is the Java translation, for comparison.
   #
   #
   # IDL Type           Moose                                                         Java
   # float              Num                                                           float
   # double		Num							      double
   # long double	Num 							      double
   # short              Int, where {$_ >= -2**15 && $_ <= 2**15-1}		      short
   # long               Int, where {$_ >= -2**31 && $_ <= 2**31-1}		      int
   # long long          Int, where {$_ >= -2**63 && $_ <= 2**63-1}		      long
   # unsigned short     Int, where {$_ >=      0 && $_ <= 2**16-1}		      short
   # unsigned long      Int, where {$_ >=      0 && $_ <= 2**32-1}		      int
   # unsigned long long Int, where {$_ >=      0 && $_ <= 2**64-1}		      long
   # char               Str[1]       // will handle MORE than it should in theory     char
   # wchar              Str[1]	     	     	    	      	 	   	      char
   # boolean            Bool							      boolean
   # octet              Int where {$_ >= 0 && $_ <= 255}			      byte
   # Any                Dict[TypeCode => Num, TypeValue => Any]			      org.omg.CORBA.Any
   # Object             Object							      /
   # union              union							      class
   # enum               enum							      class
   # struct             structure						      class
   # sequence           ArrayRef						      Array
   # array              ArrayRef						      Array
   # string             Str							      String
   # wstring            Str							      String
   # an interface is an abstract class
   #
   # IDL has these particularities:
   #
   # * A module can be "reopened".
   #
   #   This is not a problem for perl: it is legal to say:
   #     package test { xxx }
   #
   #   and later:
   #     package test { yyy }
   #
   #   The twos will happily concatenate
   #
   # * The most important chapter of IDL specification is 5.20 about
   #   Scoping rules and Names resolution
   #
   # - Identifiers:
   # "An identifier can only be defined once in a scope. However, identifiers can be redefined in nested scopes. An identifier
   #  declaring a module is considered to be defined by its first occurrence in a scope."
   #
   # This mean that have simply keep the enclosed construct of IDL, i.e. role xx { role y { role z { ... }}}
   #
   # And:
   #
   # "An identifier from a surrounding scope is introduced into a scope if it is used in that scope. An identifier is not introduced
   #  into a scope by merely being visible in that scope. The use of a scoped name introduces the identifier of the outermost
   #  scope of the scoped name."
   #
   # This is perfectly compatible with role composition.
   #
   # Also:
   #
   # "A qualified name of the form ::X::Y::Z does not cause X to be introduced, but a qualified name of the form X::Y::Z does."
   #
   # C.f. processing of IDL::AST::scopedName
   #
~%]
#!env perl

use MooseX::Declare;

[% # The whole IDL file is describing what is "Role" in Moose terminology
   # Instead of requiring the ScalarUtil, Dumper etc... plugin, the following methods are explicitely provided by the caller:
   # - Scalar::Utils::blessed()
   # - Scalar::Utils::reftype()
   # - Data::Dumper()
   # TT2 does not like blessed arrays, we provide a method that return the content: as_list
   # - as_list()
   #
   # As of time of of this writing, nested namespaces are not supported by MooseX::Declare
   # so they are explicitely setted
   #
~%]
[% PROCESS ast2perl item=ast
                    indent=0
                    root=[]
                    scope=[]
                    withHash={}
                    sfqnHash={}
                    traitsHash={}
                    useHash={}
                    extendsHash={}
                    class_hasHash={}
                    subtypesDeclHash={}
                    basictypesDeclHash={}
                    allypesHash={}
                    bodyHash={} %]
[% nl %]
[%~ RETURN ~%]

[%~# Remember: AST is always a blessed array reference. Every item inside as well, EXCEPT hardcoded lexemes ~%]

[%~ BLOCK printDump ~%]
  [%~ PERL ~%]
    use Data::Dumper;
    print Dumper($stash->get('what'));
  [%~ END ~%]
[%~ END ~%]
[%~ BLOCK printLexeme; lexeme(as_list(item.0));  END ~%]

[%~ BLOCK pushRoot;  dummy = root.push(root.size == 0 ? what : '::' _ what);   END ~%]
[%~ BLOCK printRoot; root.join('');            END ~%]
[%~ BLOCK printFirstRoot; root.0;              END ~%]
[%~ BLOCK popRoot;   dummy = root.pop();       END ~%]

[%~ BLOCK pushScope;  dummy = scope.push('::' _ what); END ~%]
[%~ BLOCK printScope; scope.join('');          END ~%]
[%~ BLOCK popScope;   dummy = scope.pop();     END ~%]
[%~ BLOCK printLastScope;  scope.reverse.0;    END ~%]

[% # SFQN means Scope Fully Qqalified Name %]
[%~ BLOCK SFQN; INCLUDE printRoot; INCLUDE printScope; what ? (root.size == 0 ? what : '::' _ what) : '';  END ~%]

[% # TTFQN means Type Fully Qualified Name %]
[%~ BLOCK TTFQN ~%]
  [%~ IF typeSpec.match('::') ~%]
    [%~ # It is already fully qualified ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ typeSpec ~%];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
    [%~ RETURN ~%]
  [%~ END ~%]
  [%~ # Loop on all known subtypesDecl as this point in parsing ~%]
  [%~ tmpScope = INCLUDE SFQN what='' ~%]
  [%~ splitted = tmpScope.split('::') ~%]
  [%~ i = splitted.max ~%]
  [%~ WHILE (i >= 0) ~%]
    [%~ tmpScope = splitted.splice(0, i) ~%]
    [%~ IF exists(alltypesHash.$tmpScope.$typeSpec) ~%]
      [%~ IF (i == splitted.max) ~%]
        [%~ # Found in current scope, no need to fully qualify it ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ typeSpec ~%];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]
      [%~ END ~%]
      [%~ # Return the fully qualified type ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ tmpScope.typeSpec ~%];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
      [%~ RETURN ~%]
    [%~ END ~%]
  [%~ END ~%]
  [%~ # Here we have a problem ~%]
  [%~ PERL ~%]
    print STDERR "Unresolved type " . $stash->get('typeSpec') . "\n"
  [%~ END ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ typeSpec ~%];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ RETURN ~%]
[%~ END ~%]

[%~ BLOCK xxxExpr ~%]
  [%~ rhs = as_list(item) ~%]
  [%~ IF rhs.max == 2 ~%]
    [%~ INCLUDE ast2perl item=rhs.0 %]
    [%~ INCLUDE printLexeme item=rhs.1 ~%]
    [%~ INCLUDE ast2perl item=rhs.2 %]
  [%~ ELSE ~%]
    [%~ INCLUDE ast2perl item=rhs.0 %]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printWith ~%]
  [%~ IF withHash.$blockName.size > 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(1) %]with ([%~ withHash.$blockName.join(', ') ~%])
[%~#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printUse ~%]
  [%~ FOREACH use IN useHash.$blockName.keys ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(useIndent) %]use [% use ~%];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printExtends ~%]
  [%~ IF extendsHash.$blockName.size > 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(1) %]extends ([%~ extendsHash.$blockName.join(', ') ~%])
[%~#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printSubtypesDecl ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(subtypesDeclIndent) %]use MooseX::Types::Moose -all;
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ IF subtypesDeclHash.$blockName.keys.size > 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(subtypesDeclIndent) %]use MooseX::Types -declare => [qw/[%~ subtypesDeclHash.$blockName.keys.join(' ') ~%]/];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ IF blockName == moduleName ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% nl %]
[% INCLUDE printBasictypesDecl basictypesDeclIndent=blockIndent+2 %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printBasictypesDecl ~%]
  [%~ FOREACH basictype IN basictypesDeclHash.$blockName.keys ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(basictypesDeclIndent) %]my [% basictype %] = subtype([% basictypesDeclHash.$blockName.$basictype %]);  # internal
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK printClassHas ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(classHasIndent) %]use MooseX::ClassAttribute;
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK initBlock ~%]
  [%~ useHash.$blockName = {} ~%]
  [%~ class_hasHash.$blockName = 0 ~%]
  [%~ subtypesDeclHash.$blockName = {} ~%]
  [%~ alltypesHash.$blockName = {} ~%]
  [%~ withHash.$blockName = [] ~%]
  [%~# sfqnHash is subject to scope reopening, so not resetted here ~%]
  [%~# sfqnHash.$blockName = [] ~%]
  [%~ traitsHash.$blockName = [] ~%]
  [%~ extendsHash.$blockName = [] ~%]
[%~ END ~%]

[%~ BLOCK printBlock ~%]
  [%~ blockName = INCLUDE SFQN what='' ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(blockIndent); blockType _ ' ' _ blockName %][% INCLUDE printExtends %][% INCLUDE printWith %] {
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%# We want to systematically import type constraints from the outer scope ~%]
  [%# This has to be done now, and not after an eventual MooseX::Types -declare ~%]
  [%# This is ensuring the VISIBILITY is all type constraints and methods ~%]
  [%# but this does NOT meanThis is ensuring the VISIBILITY is all type constraints and methods ~%]
  [%~ IF blockName.match('::') ~%]
    [%~ splitted = blockName.split('::') ~%]
    [%~ dummy = splitted.pop ~%]
    [%~ previousBlockName = splitted.join('::') ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(blockIndent+2) %]use [% previousBlockName %] ':all';
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ IF useHash.$blockName.keys.size > 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printUse useIndent=blockIndent+2 %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ IF class_hasHash.$blockName  ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printClassHas classHasIndent=blockIndent+2 %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~# Inside a role or a class, we want to systematically have an associated type ~%]
  [%~# This is a derived way to apply IDL constraint that a package or an interface ~%]
  [%~# name cannot be reused as an identifier within the enclosing scope -; ~%]
  [%~# Please note that IDL imposes that scoped names are case isensitive for their ~%]
  [%~# unicity match ONLY, case sensitivity is kept for the underlying implementation ~%]
  [%~ lcIdentifier = blockName.split('::').last.lower ~%]
  [%~ subtypesDeclHash.$blockName.$lcIdentifier = lcIdentifier ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printSubtypesDecl subtypesDeclIndent=blockIndent+2 %]
[% INCLUDE printSfqn sfqn=blockName sfqnIndent=blockIndent+2 %]
[% sp(blockIndent+2); bodyHash.$blockName %]
[% sp(blockIndent) %]};
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK pushBasictype ~%]
  [%~ tmpScope = INCLUDE SFQN what='' ~%]
  [%~ tmpTypeName = '$_' _ typeName ~%]
  [%~ basictypesDeclHash.$tmpScope.$tmpTypeName = typeSpec ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% tmpTypeName %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK pushSfqn ~%]
  [%~ tmpSfqn = (sfqnScope != '') ? sfqnScope _ '::' _ sfqnIdentifier : sfqnIdentifier %]
  [%~ lcSfqn = tmpSfqn.lower ~%]
  [%~ IF sfqnHash.exists(lcSfqn) ~%]
    [%~# This is acceptable only if this was a forwarded declaration that is already printed ~%]
    [%~ IF (sfqnHash.$lcSfqn.forwarded || sfqnHash.$lcSfqn.printed) ~%]
      [%~ IF ! ignoreSfqnAlreadyExist ~%]
        [%~ THROW sfqn "Case-insensitive'd scoped name $sfqn already exist" ~%]
      [%~ ELSE ~%]
        [%~ RETURN ~%]
      [%~ END ~%]
    [%~ END ~%]
  [%~ END ~%]
  [%~ sfqnHash.$lcSfqn = {scope => sfqnScope,
                          identifier => sfqnIdentifier,
                          type => sfqnType,
                          forwarded => forwarded || 0,
                          printed => printed || 0} ~%]
[%~ END ~%]

[%~ BLOCK printSfqn ~%]
  [%~ tmpSfqn = (sfqnScope != '') ? sfqnScope _ '::' _ sfqnIdentifier : sfqnIdentifier %]
  [%~ lcSfqn = tmpSfqn.lower ~%]
  [%~ IF sfqnHash.exists(lcSfqn) ~%]
    [%~ IF sfqnHash.$lcSfqn.printed == 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(sfqnIndent) %]my \$[% sfqnHash.$lcSfqn.identifier %] = [% sfqnHash.$lcSfqn.type %];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
    [%~ END ~%]
  [%~ ELSE ~%]
    [%~ PERL ~%]use Data::Dumper; print STDERR Dumper($stash->get('sfqnHash'));[%~ END ~%]
    [%~ THROW sfqn "Case-insensitive'd scoped name $sfqn does not exist" ~%]
  [%~ END ~%]
[%~ END ~%]

[%~ BLOCK ast2perl ~%]
  [% indent = newindent || indent ~%]
  [%~ blessedName = blessed(item) ~%]
  [%~ IF blessedName ~%]
    [%~ SWITCH blessedName ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::module' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.1 | trim ~%]
        [%~ moduleName = identifier ~%]

        [%~ INCLUDE pushRoot what=identifier ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]

        [%~# We reserve identifier within the scope identifier ~%]
        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = 'create_class_type_constraint(__PACKAGE__)' ~%]
        [%~# Because a scope can be reopened, we set the flag ignoreSfqnAlreadyExist ~%]
        [%~ INCLUDE pushSfqn ignoreSfqnAlreadyExist=1 ~%]

        [%~ INCLUDE initBlock blockName=tmpScope ~%]
        [%~ withHash.$tmpScope.push('MooseX::Traits') ~%]
        [%~ bodyHash.$tmpScope = INCLUDE ast2perl item=as_list(item).3 newindent=indent+2 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printBlock blockIndent=indent blockType='class' %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ INCLUDE popRoot ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::forwardDcl' ~%]
      [%~################################################ ~%]
        [%~# Per def forwardDcl is only for interfaces, i.e. a role ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.2 | trim ~%]

        [%~ tmpScope = INCLUDE SFQN what=identifier ~%]

        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = 'create_role_type_constraint(' _ tmpScope _ ')' ~%]
        [%~# Because a scope can be declared forward more than once, we set the flag ignoreSfqnAlreadyExist ~%]
        [%~ INCLUDE pushSfqn forwarded=1 ignoreSfqnAlreadyExist=1 ~%]

[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ INCLUDE printSfqn sfqnIndent=indent ~%]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::exceptDcl' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.1 | trim ~%]
        [%~ memberAny = rhs.3 ~%]
        [%~ INCLUDE pushScope what=identifier ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]

        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = 'create_role_type_constraint(__PACKAGE__)' ~%]
        [%~# Because a scope can be reopened, we set the flag ignoreSfqnAlreadyExist ~%]
        [%~ INCLUDE pushSfqn ignoreSfqnAlreadyExist=1 ~%]

        [%~ INCLUDE initBlock blockName=tmpScope ~%]
        [%~ withHash.$tmpScope.push('Throwable') ~%]
        [%~ bodyHash.$tmpScope = INCLUDE ast2perl memberCtx='attribute' item=memberAny newindent=indent+2 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printBlock blockIndent=indent blockType='role' %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ INCLUDE popScope ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::memberList' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]

[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Dict[
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ FOREACH member IN rhs ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE ast2perl memberCtx='structure' item=member | trim %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::member' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ typeSpec = INCLUDE ast2perl item=rhs.0 |trim ~%]
        [%~ declarators = INCLUDE ast2perl item=rhs.1 |trim ~%]

        [%~ IF memberCtx == 'attribute' ~%]
          [%~ FOREACH declarator IN declarators.split(', ') ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% loop.index() > 0 ? nl : '' %][% sp(indent) %]has '[% declarator %]' => (is => 'rw', isa => [% typeSpec %]);
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ END ~%]
        [%~ ELSIF memberCtx == 'structure' ~%]
          [%~ FOREACH declarator IN declarators.split(', ') ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% loop.index() > 0 ? nl : '' %][% sp(indent) %][% declarator %] => [% typeSpec %],
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ END ~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::interfaceHeader' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.2 | trim ~%]
        [%~ interfaceInheritanceSpecMaybe = rhs.3 ~%]

        [%~ tmpScope = INCLUDE SFQN what=identifier ~%]

        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = 'create_role_type_constraint(' _ tmpScope _ ')' ~%]
        [%~# Because a scope can be reopened, we set the flag ignoreSfqnAlreadyExist ~%]
        [%~ INCLUDE pushSfqn ignoreSfqnAlreadyExist=1 ~%]

        [%~ INCLUDE initBlock blockName=tmpScope ~%]
        [%~ #use = 'MooseX::Interface' ~%]
        [%~ #useHash.$tmpScope.$use = 1 ~%]
        [%~ INCLUDE ast2perl tmpScopeForInheritance=tmpScope item=interfaceInheritanceSpecMaybe newindent=indent+2 ~%]
        [% INCLUDE pushScope what=identifier %]
        [%~# interfaceDcl will close the scope ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::interfaceDcl' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ interfaceHeader = rhs.0 ~%]
        [%~ interfaceBody = rhs.2 ~%]

        [%~ INCLUDE ast2perl item=interfaceHeader ~%]
        [%~# interfaceHeader has opened the scope ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]
        [%~ # JDD bodyHash.$tmpScope = INCLUDE ast2perl item=interfaceBody newindent=indent+2 %]
        [%~ bodyHash.$tmpScope = INCLUDE ast2perl item=interfaceBody newindent=indent+2 %]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ INCLUDE printBlock blockIndent=indent blockType='role' ~%]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ identifier = INCLUDE printLastScope ~%]
        [%~ identifier = identifier.replace('::', '') ~%]
        [%~ INCLUDE popScope ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]
        [%~ subtypesDeclHash.$tmpScope.$identifier = identifier ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]role_type [% identifier %], {role => as [% identifier %]};

[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::interfaceNameListMany' ~%]
      [%~################################################ ~%]
        [%~ FOREACH interfaceName IN as_list(item) ~%]
          [%~ scopedName = as_list(interfaceName) ~%]
          [%~# C.f. AST/Value.pm, where concatenation of scopedName is already done, so that scopedName looks like a lexeme ~%]
          [%~# If scopedName begins with '::', this is an absolute scope, otherwise a relative scope ~%]
          [%~ identifier = INCLUDE printLexeme item=scopedName ~%]
          [%~ IF identifier.match('^::') ~%]
            [%~ identifier = "'" _ identifier _ "'" ~%]
          [%~ ELSE ~%]
            [%~ identifier = INCLUDE SFQN what=identifier ~%]
          [%~ END ~%]
          [%~ withHash.$tmpScopeForInheritance.push(identifier) ~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::declaratorListMany' ~%]
      [%~################################################ ~%]
        [%~ FOREACH rhs IN as_list(item) ~%]
          [%~ declarator = INCLUDE ast2perl item=rhs | trim ~%]
[%~#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[%~ loop.index() > 0 ? ', ' : '' ~%]
[%~ declarator ~%]
[%~#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::typeDcl' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ firstItem = rhs.0 ~%]
        [%~ IF NOT blessed(firstItem) ~%]
          [%~ IF firstItem == 'typedef' ~%]
            [%~ typeDeclarator = rhs.1 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE ast2perl item=typeDeclarator | trim %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
            [%~ RETURN ~%]
          [%~ END ~%]
        [%~ END ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::sequenceType' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ simpleTypeSpec = rhs.2 ~%]
        [%~ IF rhs.size == 6 ~%]
          [%~ positiveIntConst = INCLUDE ast2perl item=rhs.4 | trim ~%]
        [%~ ELSE ~%]
          [%~ positiveIntConst = -1 ~%]
        [%~ END ~%]
        [%~ IF positiveIntConst >= 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]ArrayRef[[%~ INCLUDE ast2perl item=simpleTypeSpec | trim | replace("'", "") ~%]], where {scalar(@_) <= [% positiveIntConst %]}
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ ELSE ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]ArrayRef[[%~ INCLUDE ast2perl item=simpleTypeSpec | trim | replace("'", "") ~%]]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::stringType' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ IF rhs.max == 3 ~%]
          [%~ positiveIntConst = INCLUDE ast2perl item=rhs.3 | trim ~%]
        [%~ ELSE ~%]
          [%~ positiveIntConst = -1 ~%]
        [%~ END ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Str
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ IF positiveIntConst >= 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% ', where {length($_) <= ' _ positiveIntConst _ '},
  message { "Length must not be <= ' _ positiveIntConst _ '" },
    ( $Moose::VERSION >= 2.0200
        ? inline_as {
            $_[0]->parent()->_inline_check( $_[1] ) . \' && \'
                . qq{ (length($_[1]) > 0) };
        }
        : ()
    );' %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::wideStringType' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ IF rhs.max == 3 ~%]
          [%~ positiveIntConst = INCLUDE ast2perl item=rhs.3 | trim ~%]
        [%~ ELSE ~%]
          [%~ positiveIntConst = -1 ~%]
        [%~ END ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Str
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ IF positiveIntConst >= 0 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% ', where {length($_) <= ' _ positiveIntConst _ '},
  message { "Length must not be <= ' _ positiveIntConst _ '" },
    ( $Moose::VERSION >= 2.0200
        ? inline_as {
            $_[0]->parent()->_inline_check( $_[1] ) . \' && \'
                . qq{ (length($_[1]) > 0) };
        }
        : ()
    );' %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::floatingPtType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Num
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::signedShortInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='signedShortInt' typeSpec='Int, where {$_ >= -2**15 && $_ <= 2**15-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::signedLongInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='signedLongInt' typeSpec='Int, where {$_ >= -2**31 && $_ <= 2**31-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::signedLonglongInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='signedLonglongInt' typeSpec='Int, where {$_ >= -2**63 && $_ <= 2**63-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::unsignedShortInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='unsignedShortInt' typeSpec='Int => where {$_ >= 0 && $_ <= 2**16-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::unsignedLongInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='unsignedLongInt' typeSpec='Int, where {$_ >= 0 && $_ <= 2**32-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::unsignedLonglongInt' ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='unsignedLonglongInt' typeSpec='Int, where {$_ >= 0 && $_ <= 2**64-1}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::octetType' ~%]
      [%~# Note: octetType is binary data ~%]
      [%~################################################ ~%]
        [%~ INCLUDE pushBasictype typeName='octetType' typeSpec='Int, where {$_ >= 0 && $_ <= 255}' ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::anyType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Dict[TypeCode => Num, TypeValue => Any]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::unionType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]JDD TO DO
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::objectType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Object
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::charType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Str[1]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::wideCharType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Str[1]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::booleanType' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]Bool
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~# No need to go further ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::orExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::xorExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::andExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::shiftExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::addExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::multExpr' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE xxxExpr %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::constDcl' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ constType = INCLUDE ast2perl item=rhs.1 | trim ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.2 | trim ~%]
        [%~ constExp = INCLUDE ast2perl item=rhs.4 | trim ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]
        [%~ class_hasHash.$tmpScope = 1 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]class_has [% identifier %] => (is => 'ro', isa => [% constType %], default => do {[% constExp ~%]});
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::unaryOperator' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE printLexeme item=rhs.0 | trim %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::primaryExpr' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ IF rhs.max == 2 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %](
[% INCLUDE ast2perl item=rhs.1 newindent=indent+2 %]
[% sp(indent) %])
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]
        [%~ END ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::scopedName' ~%]
      [%~################################################ ~%]
        [%# scopedName = INCLUDE SFQN what=lexeme(as_list(item)) %]
        [% scopedName = lexeme(as_list(item)) %]
        [%~# If scopedName is in the form X::Y::Z then scope X::Y is introduced ~%]
        [% IF (matches = scopedName.match('^[^:]+::')) %]
          [%~ splitted = scopedName.split('::') ~%]
          [%~ latest = splitted.pop ~%]
          [%~ toImport = splitted.join('::') ~%]
          [%~ tmpScope = INCLUDE SFQN what='' ~%]
          [%~ dummy = withHash.$tmpScope.push(toImport) ~%]
        [% END %]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]\$[%~ scopedName %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::identifier' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE printLexeme %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::integerLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE printLexeme %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::fixedPtLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE printLexeme %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::floatingPtLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %][% INCLUDE printLexeme %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::stringLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]"[% INCLUDE printLexeme %]"
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::wideStringLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]"[% INCLUDE printLexeme %]"
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::characterLiteral' ~%]
      [%~################################################ ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]"[% INCLUDE printLexeme %]"
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::booleanLiteral' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ booleanLiteral = INCLUDE printLexeme item=rhs.0 | trim ~%]
        [%~ IF booleanLiteral == 'TRUE' ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]1
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ ELSE ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]0
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
          [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::valueBoxDcl' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.1 | trim ~%]
        [%~ typeSpec = INCLUDE ast2perl item=rhs.2 | trim ~%]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]
        [%~ subtypesDeclHash.$tmpScope.$identifier = typeSpec ~%]
        [%~ alltypesHash.$tmpScope.$typeSpec = 1 ~%]

        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = typeSpec ~%]
        [%~ INCLUDE pushSfqn ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printSfqn sfqnIndent=indent %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::structType' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ identifier = INCLUDE printLexeme item=rhs.1 | trim ~%]
        [%~ memberList = INCLUDE ast2perl memberCtx='structure' item=rhs.3 newindent=indent+2 | trim %]
        [%~ tmpScope = INCLUDE SFQN what='' ~%]
        [%~ subtypesDeclHash.$tmpScope.$identifier = memberList ~%]
        [%~ alltypesHash.$tmpScope.$memberList = 1 ~%]

        [%~ sfqnScope = tmpScope ~%]
        [%~ sfqnIdentifier = identifier ~%]
        [%~ sfqnType = memberList ~%]
        [%~ INCLUDE pushSfqn ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE printSfqn sfqnIndent=indent %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::typeDeclarator' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ typeSpec = INCLUDE ast2perl item=rhs.0 | trim ~%]
        [%~ declarators = INCLUDE ast2perl item=rhs.1 | trim ~%]
        [%~# We are lucky that only this rule correspond to typedef - ~%]
        [%~ FOREACH declarator IN declarators.split(', ') ~%]
          [%~ tmpScope = INCLUDE SFQN what='' ~%]
          [%~ subtypesDeclHash.$tmpScope.$declarator = typeSpec ~%]
          [%~ alltypesHash.$tmpScope.$typeSpec = 1 ~%]
          [%~ sfqnScope = tmpScope ~%]
          [%~ sfqnIdentifier = declarator ~%]
          [%~ sfqnType = typeSpec ~%]
          [%~ INCLUDE pushSfqn ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% loop.index() > 0 ? nl : '' %][% INCLUDE printSfqn sfqnIndent=indent %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ END ~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::readonlyAttrSpec' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ paramTypeSpec = INCLUDE ast2perl item=rhs.2 | trim ~%]
        [%~ readonlyAttrDeclarator = INCLUDE ast2perl item=rhs.3 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]has '[% readonlyAttrDeclarator %]' => (is => 'ro', isa => [% paramTypeSpec %]);
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~################################################ ~%]
      [%~ CASE 'IDL::AST::attrSpec' ~%]
      [%~################################################ ~%]
        [%~ rhs = as_list(item) ~%]
        [%~ paramTypeSpec = INCLUDE ast2perl item=rhs.1 | trim ~%]
        [%~ attrDeclarator = INCLUDE ast2perl item=rhs.2 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% sp(indent) %]has '[% attrDeclarator %]' => (is => 'rw', isa => [% paramTypeSpec %]);
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
        [%~ RETURN ~%]

      [%~ CASE DEFAULT ~%]

    [%~ END ~%]
    [%~ FOREACH rhs IN as_list(item) ~%]
      [%~ INCLUDE ast2perl item=rhs ~%]
    [%~ END ~%]
  [%~ END ~%]
[%~ END ~%]
