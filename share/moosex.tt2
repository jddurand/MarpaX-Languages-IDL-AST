[%~ # ######################################################################## ~%]
[%~ # TT2 is called with these variable pre-filled:                            ~%]
[%~ #                                                                          ~%]
[%~ # ast                         an AST value as returned by parse()          ~%]
[%~ # cr($n)                      Output CR x $n                               ~%]
[%~ # nl($n)                      Output NL x $n                               ~%]
[%~ # sp($n)                      Output SP x $n                               ~%]
[%~ # tab($n)                     Output TAB x $n                              ~%]
[%~ #                                                                          ~%]
[%~ # TT2 is great except for the space management which is not easy.          ~%]
[%~ # My technique is to surround any output by [%#>>>~]...[%#<<<~] and to use ~%]
[%~ # trim when a block is surrounding another.                                ~%]
[%~ #                                                                          ~%]
[%~ #                                                                          ~%]
[%~ # ######################################################################## ~%]
[%~ USE ScalarUtil ~%]
[%~ USE PerlTidy ~%]
[%~ FILTER $PerlTidy ~%]
#!env perl

use Module::Load qw/load/;
use MooseX::Declare;

[% PROCESS _process processArg0=ast processArg1='specification' | $PerlTidy %]
[%~ END ~%]

[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]
[%~ #                       TEMPLATE TOOLKIT TOOLS                               ~%]
[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]

[%~ BLOCK scopedName ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
\$[% INCLUDE _lexeme lexemeArg0=array %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK STRINGLITERALUNIT ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE _lexeme lexemeArg0=array %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK importedScope ~%]
  [%~ importedScopeValue = INCLUDE _process processArg0=array.0 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
load [% importedScopeValue %];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ BLOCK _lexeme ~%]
  [%~ # ######################################################################## ~%]
  [%~ # Outputs a lexeme value                                                   ~%]
  [%~ #                                                                          ~%]
  [%~ # Input: lexemeArg0          an array ref of [start, length, value]        ~%]
  [%~ # ######################################################################## ~%]
[% lexemeArg0.2 %]
[%~ END ~%]

[%~ BLOCK _process ~%]
  [%~ # ######################################################################## ~%]
  [%~ # Scan the AST using a stack-light model                                   ~%]
  [%~ #                                                                          ~%]
  [%~ # Input: processArg0          an AST LHS blessed item                      ~%]
  [%~ #                                                                          ~%]
  [%~ # At every LHS, an PROCESS will be called i.e.:                            ~%]
  [%~ #                             PROCESS $lhs array                           ~%]
  [%~ # where array contains the RHS                                             ~%]
  [%~ #                                                                          ~%]
  [%~ # The call to PROCESS is surrounded by a TRY so that if a block for a      ~%]
  [%~ # given LHS does not exist, this will be silently ignored and the          ~%]
  [%~ # procedure will continue with the next LHS, in order they appear in the   ~%]
  [%~ # AST                                                                      ~%]
  [%~ #                                                                          ~%]
  [%~ # IF the PROCESS'ed block exist and puts the variable processStop to a     ~%]
  [%~ # false value, any subtree starting from $lhs will continue.               ~%]
  [%~ # Default is to always stop any subtree for any existing PROCESS'ed blocc. ~%]
  [%~ # Usually an existing LHS block will put this variable to a true value if  ~%]
  [%~ # it wants the subtree to continue. Typicall usage is when current LHS is  ~%]
  [%~ # wrapping inner content. For example, ArrayRef[...]                       ~%]
  [%~ #                                                                          ~%]
  [%~ # To perform localisation, in a PROCESS'ed block you will use INCLUDE      ~%]
  [%~ #                                                                          ~%]
  [%~ # ######################################################################## ~%]
  [%~ IF (! processArg0) ~%]
    [%~ THROW processArg0 "Missing argument" ~%]
  [%~ END ~%]
  [%~ IF (! processArg1) ~%]
    [%~ THROW processArg1 "Missing argument" ~%]
  [%~ END ~%]

  [%~ worklist = [ processArg0 ] %]
  [%~ WHILE worklist.size > 0 %]
    [%~ obj = worklist.shift ~%]
    [%~ TRY ~%]
      [%~ blessed = ScalarUtil.blessed(obj) ~%]
      [%~ shortBlessedName = blessed.split('::').last ~%]
    [%~ CATCH ~%]
      [%~ blessed = '' ~%]
      [%~ shortBlessedName = '' ~%]
    [%~ END ~%]
    [%~ IF shortBlessedName ~%]
      [%~ obj2array = [] ~%]
      [%~ PERL ~%]
        [%~ # ------------------------------------------------------------------------ ~%]
        [%~ # TT2 does not like blessed arrays, we provide our PERL function to get'em ~%]
        [%~ # ------------------------------------------------------------------------ ~%]
        # Store RHS list in variable 'array'
        my $arrayp = $stash->get('obj');
        $stash->set('obj2array', [ @{$arrayp} ]);
      [%~ END ~%]
      [%~ processStop = 1 ~%]
      [%~ TRY ~%]
  [%~ PERL ~%]
print STDERR "Trying PROCESS " . $stash->get('shortBlessedName') . "\n";
  [%~ END ~%]
        [%~ PROCESS $shortBlessedName array=obj2array ~%]
      [%~ CATCH ~%]
        [%~ processStop = 0 ~%]
        [%~ CLEAR ~%]
      [%~ END ~%]
      [%~ PERL ~%]
      [%~ END ~%]
      [%~ IF ! processStop ~%]
        [%~ PERL ~%]
          [%~ # ------------------------------------------------------------------------ ~%]
          [%~ # I believe this is quicker to do the unshift myself, true ?               ~%]
          [%~ # ------------------------------------------------------------------------ ~%]
          my $arrayp = $stash->get('obj2array');
          my $worklist = $stash->get('worklist');
          # Unshift array into worklist
          unshift(@{$worklist}, @{$arrayp});
          $stash->set('worklist', $worklist);
        [%~ END ~%]
      [%~ ELSE ~%]
        [%~ PERL ~%]
print STDERR "Process stop on " . $stash->get('shortBlessedName') . "\n";
        [%~ END ~%]
      [%~ END ~%]
    [%~ END ~%]
    [%~ TRY ~%]
      [%~ refType = ScalarUtil.reftype(obj) ~%]
    [%~ CATCH ~%]
      [%~ refType = '' ~%]
    [%~ END ~%]
  [%~ END ~%]
[%~ END ~%]

