[%~ # ######################################################################## ~%]
[%~ # TT2 is called with these variable pre-filled:                            ~%]
[%~ #                                                                          ~%]
[%~ # ast                         an AST value as returned by parse()          ~%]
[%~ # cr($n)                      Output CR x $n                               ~%]
[%~ # nl($n)                      Output NL x $n                               ~%]
[%~ # sp($n)                      Output SP x $n                               ~%]
[%~ # tab($n)                     Output TAB x $n                              ~%]
[%~ #                                                                          ~%]
[%~ # TT2 is great except for the space management which is not easy.          ~%]
[%~ # My technique is to surround any output by [%#>>>~]...[%#<<<~] and to use ~%]
[%~ # trim when a block is surrounding another.                                ~%]
[%~ #                                                                          ~%]
[%~ #                                                                          ~%]
[%~ # ######################################################################## ~%]
[%~ USE ScalarUtil ~%]
[%~ USE PerlTidy ~%]
[%~ FILTER $PerlTidy ~%]
#!env perl

use Module::Load qw/load/;
use MooseX::Declare;

[% PROCESS _process processArg0=ast processArg1='specification' | $PerlTidy %]
[%~ END ~%]

[%~ # ************************************************************************** ~%]
[%~ #                       TEMPLATE TOOLKIT TOOLS                               ~%]
[%~ # ************************************************************************** ~%]

[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]
[%~ #                         LEXEMES OF INTEREST                                ~%]
[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]

[%~ BLOCK scopedName ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
\$[% INCLUDE _lexeme lexemeArg0=array %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK STRINGLITERALUNIT ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% INCLUDE _lexeme lexemeArg0=array %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK IDENTIFIER ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
\$[% INCLUDE _lexeme lexemeArg0=array %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
[%~ END ~%]

[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]
[%~ #                           RULES OF INTEREST                                ~%]
[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]

[%~ BLOCK importedScope ~%]
  [%~ #
      # <importedScope>              ::= <scopedName>
      #                              |   <stringLiteral>
      # ~%]
  [%~ importedScopeValue = INCLUDE _process processArg0=array.0 | trim ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
load [% importedScopeValue %];
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK typeDcl ~%]
  [%~ #
      # <typeDcl>                    ::= TYPEDEF <typeDeclarator>
      #                              |   <structType>
      #                              |   <unionType>
      #                              |   <enumType>
      #                              |   NATIVE <simpleDeclarator>
      #                              |   <constrForwardDecl>
      # ~%]
  [%~ SWITCH ScalarUtil.blessed(array.0).split('::').last ~%]
    [%~ CASE 'TYPEDEF' ~%]
      [%~ typeDeclarator = INCLUDE _process processArg0=array.1 ~%]
      [%~ processSubtree = 0 ~%]
    [%~ CASE 'NATIVE' ~%]
      [%~ PROCESS _process processArg0=array.1 ~%]
      [%~ processSubtree = 0 ~%]
  [%~ END ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]
[%~ #                             baseTypeSpec                                   ~%]
[%~ # .......................................................................... ~%]

[%~ BLOCK floatingPtType ~%]      [%#~%]floatingPtType[%#~%]      [%~ processSubtree = 0; END ~%]
[%~ BLOCK signedShortInt ~%]      [%#~%]signedShortInt[%#~%]      [%~ processSubtree = 0; END ~%]
[%~ BLOCK signedLongInt ~%]       [%#~%]signedLongInt[%#~%]       [%~ processSubtree = 0; END ~%]
[%~ BLOCK signedLonglongInt ~%]   [%#~%]signedLonglongInt[%#~%]   [%~ processSubtree = 0; END ~%]
[%~ BLOCK unsignedShortInt ~%]    [%#~%]unsignedShortInt[%#~%]    [%~ processSubtree = 0; END ~%]
[%~ BLOCK unsignedLongInt ~%]     [%#~%]unsignedLongInt[%#~%]     [%~ processSubtree = 0; END ~%]
[%~ BLOCK unsignedLonglongInt ~%] [%#~%]unsignedLonglongInt[%#~%] [%~ processSubtree = 0; END ~%]
[%~ BLOCK charType ~%]            [%#~%]charType[%#~%]            [%~ processSubtree = 0; END ~%]
[%~ BLOCK wideCharType ~%]        [%#~%]wideCharType[%#~%]        [%~ processSubtree = 0; END ~%]
[%~ BLOCK booleanType ~%]         [%#~%]booleanType[%#~%]         [%~ processSubtree = 0; END ~%]
[%~ BLOCK octetType ~%]           [%#~%]octetType[%#~%]           [%~ processSubtree = 0; END ~%]
[%~ BLOCK anyType ~%]             [%#~%]anyType[%#~%]             [%~ processSubtree = 0; END ~%]
[%~ BLOCK objectType ~%]          [%#~%]objectType[%#~%]          [%~ processSubtree = 0; END ~%]
[%~ BLOCK valueBaseType ~%]       [%#~%]valueBaseType[%#~%]       [%~ processSubtree = 0; END ~%]

[%~ # .......................................................................... ~%]
[%~ #                             templateTypeSpec                               ~%]
[%~ # .......................................................................... ~%]

[%~ BLOCK sequenceType ~%]
  [%~ #
      # <sequenceType>               ::= SEQUENCE LT <simpleTypeSpec> COMMA <positiveIntConst> GT
      #                              | SEQUENCE LT <simpleTypeSpec> GT
      # ~%]
  [%~ simpleTypeSpec = INCLUDE _process processArg0=array.2 ~%]
  [%~ IF array.size == 6 ~%]
    [%~ positiveIntConst = INCLUDE _process processArg0=array.4 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[[% simpleTypeSpec %]], where => sub {scalar(@_) <= [% positiveIntConst %]}})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ ELSE ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[[% simpleTypeSpec %]]})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK wideStringType ~%]
  [%~ #
      # <wideStringType>             ::= WSTRING LT <positiveIntConst> GT
      #                              | WSTRING
      # ~%]
  [%~ IF array.size == 4 ~%]
    [%~ positiveIntConst = INCLUDE _process processArg0=array.2 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[wideCharType], where => sub {scalar(@_) <= [% positiveIntConst %]}})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ ELSE ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[wideCharType]})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK stringType ~%]
  [%~ #
      # <stringType>                 ::= STRING LT <positiveIntConst> GT
      #                              | STRING
      # ~%]
  [%~ IF array.size == 4 ~%]
    [%~ positiveIntConst = INCLUDE _process processArg0=array.2 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[charType], where => sub {scalar(@_) <= [% positiveIntConst %]}})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ ELSE ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => ArrayRef[charType]})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ END ~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK fixedPtType ~%]
  [%~ #
      # <fixedPtType>                ::= FIXED LT <positiveIntConst> COMMA <positiveIntConst> GT
      # ~%]
  [%~ positiveIntConst1 = INCLUDE _process processArg0=array.2 ~%]
  [%~ positiveIntConst2 = INCLUDE _process processArg0=array.4 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
subtype({as => Match::BigFloat, via => sub {my $x = Math::BigFloat->new(\$_); $x->precision([% positiveIntConst2 %]); $x->accuracy([% positiveIntConst2 %]); $x}})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]
[%~ #                             constrTypeSpec                               ~%]
[%~ # .......................................................................... ~%]

[%~ BLOCK structType ~%]
  [%~ #
      # <structType>                 ::= STRUCT <identifier> LCURLY <memberList> RCURLY
      # ~%]
  [%~ identifier = INCLUDE _process processArg0=array.1 ~%]
  [%~ memberList = INCLUDE _process processArg0=array.3 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% PERL %]
print STDERR "==> " . $stash->get('identifier') . "\n";
[% END %]
[% identifier %] = subtype({as => Dict[[% memberList %]]})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK unionType ~%]
  [%~ #
      # <unionType>                  ::= UNION <identifier> SWITCH LPAREN <switchTypeSpec> RPAREN LCURLY <switchBody> RCURLY
      # ~%]
  [%~ identifier = INCLUDE _process processArg0=array.1 ~%]
  [%~ switchTypeSpec = INCLUDE _process processArg0=array.4 ~%]
  [%~ switchBody = INCLUDE _process processArg0=array.7 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% identifier %] = subtype({as => [% switchTypeSpec %], where => sub {[% switchBody %]}})
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK enumType ~%]
  [%~ #
      # <enumType>                   ::= ENUM <identifier> LCURLY <enumeratorListMany> RCURLY
      # ~%]
  [%~ identifier = INCLUDE _process processArg0=array.1 ~%]
  [%~ enumeratorListMany = INCLUDE _process processArg0=array.3 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% identifier %] = union([qw/[% enumeratorListMany %]/])
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]
[%~ #                             declaratorListMany                             ~%]
[%~ # .......................................................................... ~%]

[%~ BLOCK declaratorListMany ~%]
  [%~ #
      # <declaratorListMany> ::= <declarator>+ separator => <comma>
      # ~%]
  [%~ declaratorListMany = [] ~%]
  [%~ FOREACH rhs IN array ~%]
    [%~ declarator = INCLUDE _process processArg0=rhs ~%]
    [%~ declaratorListMany.unshift(declarator) ~%]
  [%~ END ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% declaratorListMany.join(', ') %]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # .......................................................................... ~%]
[%~ #                              arrayDeclarator                               ~%]
[%~ # .......................................................................... ~%]

[%~ BLOCK arrayDeclarator ~%]
  [%~ #
      # <arrayDeclarator>            ::= <identifier> <fixedArraySizeMany>
      # ~%]
  [%~ identifier = INCLUDE _process processArg0=array.0 ~%]
  [%~ fixedArraySizeMany = INCLUDE _process processArg0=array.1 ~%]
[%#>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>>~%]
[% identifier %][[% fixedArraySizeMany %]]
[%#<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<~%]
  [%~ processSubtree = 0 ~%]
[%~ END ~%]

[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]
[%~ #                                  TOOLS                                     ~%]
[%~ # ++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++ ~%]

[%~ BLOCK _lexeme ~%]
  [%~ # ######################################################################## ~%]
  [%~ # Outputs a lexeme value                                                   ~%]
  [%~ #                                                                          ~%]
  [%~ # Input: lexemeArg0          an array ref of [start, length, value]        ~%]
  [%~ # ######################################################################## ~%]
[% lexemeArg0.2 %]
[%~ END ~%]

[%~ # .......................................................................... ~%]

[%~ BLOCK _process ~%]
  [%~ # ######################################################################## ~%]
  [%~ # Scan the AST using a stack-light model                                   ~%]
  [%~ #                                                                          ~%]
  [%~ # Input: processArg0          an AST LHS blessed item                      ~%]
  [%~ #                                                                          ~%]
  [%~ # At every LHS, an PROCESS will be called i.e.:                            ~%]
  [%~ #                             PROCESS $lhs array                           ~%]
  [%~ # where array contains the RHS                                             ~%]
  [%~ #                                                                          ~%]
  [%~ # The call to PROCESS is surrounded by a TRY so that if a block for a      ~%]
  [%~ # given LHS does not exist, this will be silently ignored and the          ~%]
  [%~ # procedure will continue with the next LHS, in order they appear in the   ~%]
  [%~ # AST                                                                      ~%]
  [%~ #                                                                          ~%]
  [%~ # IF the PROCESS'ed block exist and puts the variable processSubtree to a  ~%]
  [%~ # false value, any subtree starting from $lhs will will be dropped.        ~%]
  [%~ # Default is to always continue for any existing PROCESS'ed bloc until     ~%]
  [%~ # there is no more blessed item. I.e. the subtree is always ending at      ~%]
  [%~ # lexemes, because they are not blessed.                                   ~%]
  [%~ # Default processSubtree is a true value at every PROCESS call.            ~%]
  [%~ #                                                                          ~%]
  [%~ # Usually an existing LHS block will put this variable to a true value if  ~%]
  [%~ # it wants the subtree to stop. Typicall usage is when current LHS is      ~%]
  [%~ # wrapping inner content. For example, ArrayRef[...]. Then it is calling   ~%]
  [%~ # explicitely the _process again, and end with setting processSubtree to a ~%]
  [%~ # true value.                                                              ~%]
  [%~ #                                                                          ~%]
  [%~ # To perform localisation, in a PROCESS'ed block you will use INCLUDE.     ~%]
  [%~ # To perform variable settings in the same context, you will use PROCESS.  ~%]
  [%~ #                                                                          ~%]
  [%~ # ######################################################################## ~%]
  [%~ IF (! processArg0) ~%]
    [%~ THROW processArg0 "Missing argument" ~%]
  [%~ END ~%]
  [%~ IF (! processArg1) ~%]
    [%~ THROW processArg1 "Missing argument" ~%]
  [%~ END ~%]

  [%~ processWorklist = [ processArg0 ] %]
  [%~ WHILE processWorklist.size > 0 %]
    [%~ processObj = processWorklist.shift ~%]
    [%~ TRY ~%]
      [%~ processBlessed = ScalarUtil.blessed(processObj) ~%]
      [%~ processShortBlessedName = processBlessed.split('::').last ~%]
    [%~ CATCH ~%]
      [%~ processBlessed = '' ~%]
      [%~ processShortBlessedName = '' ~%]
    [%~ END ~%]
    [%~ IF processShortBlessedName ~%]
      [%~ processObj2array = [] ~%]
      [%~ PERL ~%]
        [%~ # ------------------------------------------------------------------------ ~%]
        [%~ # TT2 does not like blessed arrays, we provide our PERL function to get'em ~%]
        [%~ # ------------------------------------------------------------------------ ~%]
        # Store RHS list in variable 'array'
        my $arrayp = $stash->get('processObj');
        $stash->set('processObj2array', [ @{$arrayp} ]);
      [%~ END ~%]
      [%~ processSubtree = 1 ~%]
      [%~ TRY ~%]
  [%~ PERL ~%]
print STDERR "Trying PROCESS " . $stash->get('processShortBlessedName') . "\n";
  [%~ END ~%]
        [%~ PROCESS $processShortBlessedName array=processObj2array ~%]
      [%~ CATCH ~%]
        [% PERL %]
          # We want to send that to STDERR immediately if it is something else but 'file error'
          # We are smart enough to tell in which BLOCK it failed -;
          my $type = $stash->get([ 'error', [ 'type' ]]);
          my $processShortBlessedName = $stash->get('processShortBlessedName');
          if (! ($type =~ /^file error/)) {
            my $info = $stash->get([ 'error', [ 'info' ]]);
            print STDERR "Error when processing $processShortBlessedName! Type: $type, Info: $info\n";
          }
        [%~ END ~%]
        [%~ CLEAR ~%]
      [%~ END ~%]
      [%~ PERL ~%]
      [%~ END ~%]
      [%~ IF processSubtree ~%]
        [%~ PERL ~%]
          [%~ # ------------------------------------------------------------------------ ~%]
          [%~ # I believe this is quicker to do the unshift myself, true ?               ~%]
          [%~ # ------------------------------------------------------------------------ ~%]
          my $arrayp = $stash->get('processObj2array');
          my $processWorklist = $stash->get('processWorklist');
          # Unshift array into processWorklist
          unshift(@{$processWorklist}, @{$arrayp});
          $stash->set('processWorklist', $processWorklist);
        [%~ END ~%]
      [%~ ELSE ~%]
        [%~ PERL ~%]
print STDERR "Process stop on " . $stash->get('processShortBlessedName') . "\n";
        [%~ END ~%]
      [%~ END ~%]
    [%~ END ~%]
    [%~ TRY ~%]
      [%~ refType = ScalarUtil.reftype(processObj) ~%]
    [%~ CATCH ~%]
      [%~ refType = '' ~%]
    [%~ END ~%]
  [%~ END ~%]
[%~ END ~%]

